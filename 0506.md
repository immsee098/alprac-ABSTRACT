자바스크립트 실행 가능환경

자바스크트 : 인터프리터 언어다. (명령, 함수, 프로토타입 다 지원하는 멀티 패러다임 언어) 

- node.js 환경  ~ ES -> 서버사이드 환경 
    web api는 안 가지고 있는 이유가,,브라우저에 표기용이 아니기 때문!


- 브라우저  ~ ES+Web API -> 클라이언트 사이드 환경
    dom api -> getElement~류... 가지고 와서 브라우저에 표기하게 해주는! web api다

자바스크립트로 관리할 수 없는 아주 core한 부분을 관리하는 게 바로 ECMAScript다. 

-----------------------------

아직 ES6가 전부 다 지원하지 않기 때문에 Babel을 통해 es5로 다운그레이드 하거나 변환해주는 web-pack을 써야한다

더하기-> 메모리와 CPU가 협동해서 계산

~10+20=30을 하는 프로세스~
비어 있는 메모리에 10에 해당하는 이진수를 담는다. 
비어 있는 메모리에 20에 해당하는 이진수를 담는다.
  -> 이 비어있는 메모리 배분은 os가 적절히 배분함

var age 의 age는 식별자. 식별자는 값을 찾으러 갈 수 있게 해주는 거다.

var을 붙이면 먼저 실행됨 선언문 선! 정의란 식별자의 정체를 알려준다.

중복 선언이 허용된다.
var a = 10;
var a; 
이렇게 두 개 다 가능함
JS는 동적 타입 언어다(직접 int 등 선언 안하고 var) 근데 이게 문제가 있어서... 정적 타입으로 바꾸는 게 생김.(타입스크립트)

CS              공통            server
web API    |   ES  |    Node.js API

Node.js 는 언어가 아니라 환경이다! 
심지어 노드js는 프레임워크다. 언어는 자바스크립트이기 때문.

10. 12 .6
 a   b   c
c부분 의미: 패치버전
b부분 의미: 기능향상(사용자가 신경쓸거 x)
a부분 의미: break change ~> 전버전과 이전버전이 호환 안 될 정도의 차이


1. 주소창에 네이버 주소를 치면
2. dms주소를 통해 네이버 서버를 찾아간다 (dms란 실제적인 서버가 어디있는지 알고 있는 것)
3. 서버에서 html css js를 슝 준다 이걸 다운로드 받음(이진수의 텍스트 받음)
4. 이 파일들을 해석(parsing)해서 브라우저가 이해할 수 있는 결과물이 생김~>파싱해서 메모리에 올렸다

parsing: 해석한다
meta data: 사람에게 주기 위한 데이터가 아닌 컴퓨터에 주기 위한 데이터(링크태그나 css등)

html의 
head에는 메타 데이터 위주(유일하게 제외하는건 title)
body에는 화면에 보여지는 것 위주

html은 트리 구조(부자관계)로 되어있다. head 바로 루트다. (짱)
아래로 읽어나가며 필요한 건 메모리에 적어둔다.
유의미한 정보(html등)은 token 토큰이라 그런다

[selector]{
color: red;
font-size: 16px;
}
등 html과 관련이 있는 selector을 parser가 읽고 여러 tree를 만들어간다. (태그에 이어주고 붙여주고..) 

DOM tree 
CSSOM tree
Render tree를 만들어서 전부 합친다!
다만 자바스크립트는 자기만의 파싱 툴이 있다. 

html/css/js를 다 개별로 분리하는 방법
cvd라고 한꺼번에 붙이는 방법이 있다
개별로 분리하는 쪽이 유지보수에 좋다. 퍼포먼스에 큰 차이는 없음

1점대 버전 render engine은 3번 이상 요청해야 html/css/js를 받았음
2점대 버전 render engine은 서버 자의의 판단에 따라 html을 받으며 나머지를 받아옴(이론상으로는 1번 요청이지만,,사실 그 이상 요청하긴함)
~>2점대가 더 빠름!

서버에 요청해서 받아오는 일 자체가 무척 부하가 많이 걸리고 시간이 많이 걸려서 2점대가 좋긴함..

js는 html이 전부 완료되어있는 상태에서 실행해야함. 왜냐면 그 전에 실행되면 아무런 쓸모가 없기 때문. 자바스크립트는 기본적으로 모든 것을 비동기 처리한다

async 문제점. 절대 안 기다려줘서(..) html 먼저 다 로드됨. 그래서 dom을 조작하지 않는 경우에만 넣을 수 있음.


var a = 0;
의 var은 키워드~>예약어라고 한다
a는 변수명~>식별자
0은 값(리터럴)

compile 할 때는 compile time
parsing 할 떄는 parsing time
runtime(실행)할 떄는 runtime error(실행때 에러 나는걸 의미)

자바스크립트는 자체 컴파일을 조금씩 하지만 ""실행파일을 만들지 않는다는 점에서"" 인터프리터 언어라고 한다!!
node.js를 실행하는 방법. node라 치고 실행을 하면 화면값이 뜬다.(REPA라고 한다)

호이스팅(HOISTING):
var을 붙이면 선언이 먼저 되기 때문에 console.log를 위에 써도 아직 정의 안 된 어떤 변수(식별자)의 undefined 값이 나온다.

이게 문제가 많아서... const와 let을 만들었다. 근데 이것도 호이스팅을 불가능하게 하는 건 아니고... 불가능 한 것처럼 보여주는 것 뿐이다!

상수의 반댓말은 변수다

~식별자 네이밍~
식별자 앞에 $을 붙이면... DOM요소라는 뜻이다. 


~데이터 타입~
리터럴 : 최소 단위의 표현식. 소스코드 안에서 직접 만들어 낸 고정된 값 자체를 말한다. ~> 값을 만드는 방법으로 생각하면 된다(방법 중 가장 심플한 게 리터럴)
js의 함수에는 객체가 들어올 수 있다. 

js가 표현할 수 있는 수를 넣으면 infinite(수학에서의 무한과는 다름)
**시험!!** NaN : 산술 연산 불가

템플릿 리터럴 : html 표현에 더 좋음

선언과 정의의 차이?
정의: 정의란 변수에 값을 할당하여 변수의 실체를 명확히 하는 것을 말한다.

null을 넣는 것? undefined처럼 아예  없어지는 것이 아니라... null을 넣어버리는 것이다! 그니까 할당! null 대신 1이라 써도 ㄱㅊ

~표현식과 연산자~
문: 하나의 키워드와 식별자로 이루어져있음 ~> 명령도 있음
변수 선언문: var x
표현(할당)문: x=5
함수 선언문: function foo(){}

표현식인 문은 값처럼 사용할 수 있다
var foo = x = 100;
연쇄할당이나... 가독성 떨어짐
